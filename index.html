<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RMP MOCK TEST - Select Exams</title>
  <link rel="stylesheet" href="style.css">

  <style>
    .section { margin-top: 16px; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    .btn {
      cursor: pointer;
      border: 0;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 700;
    }
    .btn-primary { background:#1976d2; color:#fff; }
    .btn-ghost { background:#eef2f7; color:#223; }
    .btn:disabled { opacity: .55; cursor:not-allowed; }
    .hint { color:#555; font-size:.95em; line-height:1.35; }
    .status { margin-top:10px; font-weight:700; white-space:pre-line; }
    .status.ok { color: #1b5e20; }
    .status.err { color: #c62828; }

    /* ===== Exam list (compact) ===== */
    .list {
      margin-top: 10px;
      border: 1px solid rgba(0,0,0,.08);
      border-radius: 12px;
      overflow: hidden;
      background: #fff;
    }
    .list-header, .item {
      display: grid;
      grid-template-columns: 34px 1fr 44px; /* compact: checkbox | title | X */
      gap: 8px;
      align-items: center;
      padding: 6px 10px; /* compact */
    }
    .list-header {
      background: #f3f6fb;
      font-weight: 800;
      color: #334;
      border-bottom: 1px solid rgba(0,0,0,.08);
    }

    /* zebra + hover */
    .item { border-bottom: 1px solid rgba(0,0,0,.05); }
    .item:nth-child(odd) { background: #ffffff; }
    .item:nth-child(even) { background: #fbfcff; }
    .item:hover { background: #eef6ff !important; }

    .item-title { font-weight: 800; }

    .tag {
      display:inline-block;
      font-size: .85em;
      padding: 3px 8px;
      border-radius: 999px;
      background: #eef2f7;
      color: #223;
      font-weight: 700;
      margin-left: 6px;
    }

    /* 3D red X button */
    .xbtn {
      width: 28px;
      height: 28px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,.12);
      cursor: pointer;
      font-weight: 900;
      font-size: 16px;
      line-height: 26px;
      text-align: center;
      user-select: none;

      background: linear-gradient(180deg, #ffebee 0%, #ffcdd2 100%);
      color: #b71c1c;
      box-shadow:
        0 2px 0 rgba(183,28,28,.35),
        0 6px 16px rgba(183,28,28,.15);
      transform: translateY(0);
      transition: transform .08s ease, box-shadow .08s ease;
    }
    .xbtn:hover {
      box-shadow:
        0 2px 0 rgba(183,28,28,.35),
        0 10px 22px rgba(183,28,28,.22);
      transform: translateY(-1px);
    }
    .xbtn:active {
      transform: translateY(1px);
      box-shadow:
        0 1px 0 rgba(183,28,28,.35),
        0 4px 10px rgba(183,28,28,.18);
    }

    .pill {
      display:inline-block;
      margin-left: 8px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: .8em;
      font-weight: 800;
      background:#e3f2fd;
      color:#0d47a1;
    }

    /* Add more row at bottom of table */
    #add-more-row {
      padding:10px 12px;
      text-align:center;
      background:#f9fafc;
      border-top:1px dashed rgba(0,0,0,.15);
      cursor:pointer;
      font-weight:800;
      color:#1976d2;
      user-select:none;
    }
    #add-more-row:hover { background:#eef6ff; }

    /* ===== Preview Modal ===== */
    .modal-overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.45);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 9999;
    }
    .modal{
      width: min(920px, 92vw);
      max-height: 86vh;
      background:#fff;
      border-radius: 14px;
      overflow:hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,.25);
      display:flex;
      flex-direction:column;
    }
    .modal-header{
      padding: 12px 16px;
      background:#f3f6fb;
      border-bottom: 1px solid rgba(0,0,0,.08);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .modal-title{
      font-weight: 900;
      color:#223;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .modal-body{
      padding: 14px 16px;
      overflow:auto;
    }
    .q-item{
      padding: 10px 0;
      border-bottom: 1px dashed rgba(0,0,0,.12);
    }
    .q-title{
      font-weight: 800;
      margin-bottom: 8px;
      line-height: 1.35;
      white-space: pre-wrap;
    }
    .q-options{
      margin-left: 14px;
      color:#334;
      line-height: 1.35;
      white-space: pre-wrap;
    }
    .modal-footer{
      padding: 12px 16px;
      border-top: 1px solid rgba(0,0,0,.08);
      background:#fafbfe;
      display:flex;
      justify-content:flex-end;
      gap:10px;
    }
  </style>
</head>

<body>
  <div class="container" id="main-container">
    <div class="icon-main">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="#2b7cff">
        <circle cx="32" cy="32" r="30" stroke="#1976d2" stroke-width="4" fill="#e3f2fd"/>
        <text x="32" y="42" text-anchor="middle" font-size="32" fill="#1976d2" font-family="Arial" font-weight="bold">?</text>
      </svg>
      <span>üìö</span>
    </div>

    <div class="title">RMP MOCK TEST</div>

    <div class="section">
      <div class="hint">
        Click v√†o row ƒë·ªÉ ch·ªçn ƒë·ªÅ. Double click ƒë·ªÉ preview 5 c√¢u ƒë·∫ßu. Ch·ªçn xong nh·∫•n <b>Load Tests</b>.
      </div>
    </div>

    <div class="section row">
      <button class="btn btn-ghost" id="btn-refresh">Refresh List</button>
      <button class="btn btn-ghost" id="btn-select-all">Select All</button>
      <button class="btn btn-ghost" id="btn-clear-select">Clear Selection</button>
      <button class="btn btn-ghost" id="btn-delete-selected">Delete Selected (from list)</button>
    </div>

    <div class="section">
      <div class="list" id="exam-list">
        <div class="list-header">
          <div></div>
          <div>Exam</div>
          <div style="text-align:center;"></div>
        </div>

        <div id="exam-items"></div>

        <div id="add-more-row">Ôºã Add more</div>
      </div>

      <!-- hidden uploader -->
      <input type="file" id="upload" accept=".json" multiple style="display:none;" />

      <div class="status" id="status-msg"></div>
    </div>

    <div class="section row" style="justify-content:space-between;">
      <div class="hint">
        Selected exams: <b id="selected-count">0</b>
        <span class="pill" id="selected-questions-pill" style="display:none;"></span>
      </div>
      <button class="btn btn-primary" id="btn-load-tests" disabled>Load Tests</button>
    </div>
  </div>

  <!-- Preview Modal -->
  <div class="modal-overlay" id="preview-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title" id="preview-title">Preview</div>
        <button class="btn btn-ghost" id="btn-close-preview">Close</button>
      </div>
      <div class="modal-body" id="preview-body"></div>
      <div class="modal-footer">
        <button class="btn btn-primary" id="btn-close-preview-2">Close</button>
      </div>
    </div>
  </div>

  <script>
    const MANIFEST_URL = "./manifest.json";

    const LS_LIST_KEY = "pmp_exam_list_v1";
    const LS_DELETED_KEY = "pmp_exam_deleted_v1";
    const LS_UPLOAD_PREFIX = "pmp_exam_content::";
    const LS_SELECTED_KEY = "pmp_exam_selected_v1";

    const LOCALSTORAGE_SAFE_BYTES = 4_500_000; // 4.5MB safe margin

    let exams = [];
    let selectedIds = new Set();

    const $items = document.getElementById("exam-items");
    const $status = document.getElementById("status-msg");
    const $btnLoad = document.getElementById("btn-load-tests");
    const $selectedCount = document.getElementById("selected-count");
    const $selectedQuestionsPill = document.getElementById("selected-questions-pill");

    const $upload = document.getElementById("upload");
    const $addMore = document.getElementById("add-more-row");

    const $overlay = document.getElementById("preview-overlay");
    const $previewTitle = document.getElementById("preview-title");
    const $previewBody = document.getElementById("preview-body");
    const $close1 = document.getElementById("btn-close-preview");
    const $close2 = document.getElementById("btn-close-preview-2");

    // Add more -> open picker
    $addMore.addEventListener("click", () => $upload.click());

    function setStatus(msg, type) {
      $status.textContent = msg || "";
      $status.className = "status" + (type ? (" " + type) : "");
    }

    function safeJsonParse(str) {
      try { return JSON.parse(str); } catch { return null; }
    }

    function escapeHtml(s) {
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function normalizeName(name) {
      return String(name || "").trim().toLowerCase();
    }

    function baseNameFromPath(path) {
      if (!path) return "";
      const p = String(path).split("?")[0].split("#")[0];
      const seg = p.split("/").filter(Boolean);
      return seg.length ? seg[seg.length - 1] : p;
    }

    function getNavType() {
      try {
        const nav = performance.getEntriesByType("navigation");
        if (nav && nav.length) return nav[0].type; // navigate | reload | back_forward
      } catch {}
      return "navigate";
    }

    function clearAppStorageToDefault() {
      localStorage.removeItem(LS_LIST_KEY);
      localStorage.removeItem(LS_DELETED_KEY);
      localStorage.removeItem(LS_SELECTED_KEY);
      localStorage.removeItem("pmp_questions");
      localStorage.removeItem("pmp_selected_exams_meta");

      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (k && k.startsWith(LS_UPLOAD_PREFIX)) keysToRemove.push(k);
      }
      keysToRemove.forEach(k => localStorage.removeItem(k));
    }

    // Reset rule: only keep state if coming from browser Back
    (function bootResetRule() {
      const navType = getNavType();
      if (navType !== "back_forward") {
        clearAppStorageToDefault();
      }
    })();

    function loadDeletedSet() {
      const arr = safeJsonParse(localStorage.getItem(LS_DELETED_KEY)) || [];
      return new Set(arr);
    }

    function saveDeletedSet(set) {
      localStorage.setItem(LS_DELETED_KEY, JSON.stringify(Array.from(set)));
    }

    function loadSavedList() {
      return safeJsonParse(localStorage.getItem(LS_LIST_KEY)) || [];
    }

    function saveList(list) {
      localStorage.setItem(LS_LIST_KEY, JSON.stringify(list));
    }

    function loadSavedSelection() {
      const arr = safeJsonParse(localStorage.getItem(LS_SELECTED_KEY)) || [];
      return new Set(arr);
    }

    function saveSelection() {
      localStorage.setItem(LS_SELECTED_KEY, JSON.stringify(Array.from(selectedIds)));
    }

    function normalizeExam(item) {
      const id = (item && item.id) ? String(item.id) : ("exam_" + Math.random().toString(16).slice(2));
      const title = (item && (item.title || item.name)) ? String(item.title || item.name) : id;
      const src = item && item.src ? String(item.src) : null;
      const type = item && item.type ? String(item.type) : (src ? "builtin" : "uploaded");
      const addedAt = item && item.addedAt ? Number(item.addedAt) : Date.now();

      const fileName = src ? baseNameFromPath(src) : (item && item.fileName ? String(item.fileName) : "");
      const normKey = normalizeName(fileName || title);
      const normSrc = src ? normalizeName(src) : "";

      return { id, title, src, type, addedAt, fileName, normKey, normSrc };
    }

    function applyDeletedFilter(list) {
      const deleted = loadDeletedSet();
      return list.filter(x => !deleted.has(x.id));
    }

    function estimateBytesForString(str) {
      return (str ? str.length : 0) * 2;
    }

    function updateSelectedUI(extraTotalQuestions) {
      $selectedCount.textContent = String(selectedIds.size);
      $btnLoad.disabled = selectedIds.size === 0;

      if (typeof extraTotalQuestions === "number") {
        $selectedQuestionsPill.style.display = "inline-block";
        $selectedQuestionsPill.textContent = `Total questions: ${extraTotalQuestions}`;
      } else {
        $selectedQuestionsPill.style.display = "none";
        $selectedQuestionsPill.textContent = "";
      }
    }

    function normalizeQuestions(parsed) {
      if (!parsed) return [];
      if (Array.isArray(parsed)) return parsed;
      if (parsed && typeof parsed === "object") {
        if (Array.isArray(parsed.questions)) return parsed.questions;
        if (Array.isArray(parsed.data)) return parsed.data;
        if (Array.isArray(parsed.items)) return parsed.items;
      }
      return [];
    }

    async function readExamQuestions(exam) {
      if (exam.type === "uploaded") {
        const raw = localStorage.getItem(LS_UPLOAD_PREFIX + exam.id);
        const parsed = safeJsonParse(raw);
        return normalizeQuestions(parsed);
      } else {
        if (!exam.src) return [];
        const res = await fetch(exam.src, { cache: "no-store" });
        if (!res.ok) throw new Error("cannot_fetch_exam");
        const parsed = await res.json();
        return normalizeQuestions(parsed);
      }
    }

    function buildCombinedQuestions(selectedExams, questionsByExam) {
      const combined = [];
      for (const ex of selectedExams) {
        const arr = questionsByExam.get(ex.id) || [];
        for (const q of arr) {
          if (q && typeof q === "object") {
            combined.push({ ...q, __exam_id: ex.id, __exam_title: ex.title });
          } else {
            combined.push(q);
          }
        }
      }
      return combined;
    }

    function findDuplicate(existingList, candidate) {
      const cSrc = candidate.normSrc || "";
      const cKey = candidate.normKey || normalizeName(candidate.title);

      for (const ex of existingList) {
        if (cSrc && ex.normSrc && ex.normSrc === cSrc) return ex;
        if (cKey && ex.normKey && ex.normKey === cKey) return ex;
        if (normalizeName(ex.title) === normalizeName(candidate.title)) return ex;
      }
      return null;
    }

    function deleteExamById(examId) {
      const ex = exams.find(x => x.id === examId);
      if (!ex) return;

      const deleted = loadDeletedSet();
      deleted.add(examId);
      saveDeletedSet(deleted);

      if (ex.type === "uploaded") {
        localStorage.removeItem(LS_UPLOAD_PREFIX + ex.id);
        const saved = loadSavedList().map(normalizeExam).filter(x => x.id !== ex.id);
        saveList(saved);
      }

      selectedIds.delete(examId);
      saveSelection();

      init();
    }

    async function estimateTotalQuestions() {
      if (selectedIds.size === 0) {
        updateSelectedUI();
        return;
      }
      let total = 0;
      for (const id of selectedIds) {
        const ex = exams.find(x => x.id === id);
        if (!ex) continue;
        try {
          const qs = await readExamQuestions(ex);
          total += (qs || []).length;
        } catch {}
      }
      updateSelectedUI(total);
    }

    function openPreview() {
      $overlay.style.display = "flex";
      $overlay.setAttribute("aria-hidden", "false");
    }

    function closePreview() {
      $overlay.style.display = "none";
      $overlay.setAttribute("aria-hidden", "true");
    }

    $close1.addEventListener("click", closePreview);
    $close2.addEventListener("click", closePreview);
    $overlay.addEventListener("click", (e) => {
      if (e.target === $overlay) closePreview();
    });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && $overlay.style.display === "flex") closePreview();
    });

    function letter(i){ return String.fromCharCode(65 + i); }

    async function previewExam(examId) {
      const ex = exams.find(x => x.id === examId);
      if (!ex) return;

      $previewTitle.textContent = `${ex.title} ‚Äî Preview (first 5)`;
      $previewBody.innerHTML = `<div class="hint">Loading preview...</div>`;
      openPreview();

      try {
        const qs = await readExamQuestions(ex);
        const first5 = (qs || []).slice(0, 5);

        if (first5.length === 0) {
          $previewBody.innerHTML = `<div class="hint">No questions found in this exam.</div>`;
          return;
        }

        const parts = first5.map((q, idx) => {
          const questionText = escapeHtml(q?.question || "");
          const opts = Array.isArray(q?.options) ? q.options : [];
          const optHtml = opts.map((o, i) => `${letter(i)}. ${escapeHtml(o)}`).join("\n");
          return `
            <div class="q-item">
              <div class="q-title">${idx + 1}. ${questionText}</div>
              <div class="q-options">${optHtml}</div>
            </div>
          `;
        }).join("");

        $previewBody.innerHTML = parts;
      } catch (err) {
        $previewBody.innerHTML = `<div class="hint" style="color:#c62828;font-weight:800;">Preview failed. Cannot read this exam.</div>`;
      }
    }

    function renderList() {
      $items.innerHTML = "";

      if (exams.length === 0) {
        $items.innerHTML = `
          <div class="item">
            <div></div>
            <div>
              <div class="item-title">No exams found</div>
            </div>
            <div></div>
          </div>
        `;
      } else {
        for (const ex of exams) {
          const checked = selectedIds.has(ex.id) ? "checked" : "";
          const tag = ex.type === "builtin"
            ? `<span class="tag">built-in</span>`
            : `<span class="tag">uploaded</span>`;

          const row = document.createElement("div");
          row.className = "item";
          row.setAttribute("data-id", ex.id); // for row click/dblclick
          row.innerHTML = `
            <div>
              <input type="checkbox" class="chk" data-id="${escapeHtml(ex.id)}" ${checked} />
            </div>
            <div>
              <div class="item-title">${escapeHtml(ex.title)} ${tag}</div>
              <!-- NOTE: Source line intentionally hidden to keep UI clean -->
            </div>
            <div style="display:flex;justify-content:center;">
              <button class="xbtn" title="Delete" data-id="${escapeHtml(ex.id)}">‚úï</button>
            </div>
          `;
          $items.appendChild(row);
        }
      }

      updateSelectedUI();
    }

    async function fetchManifest() {
      try {
        const res = await fetch(MANIFEST_URL, { cache: "no-store" });
        if (!res.ok) throw new Error("manifest_not_found");
        const data = await res.json();
        if (!Array.isArray(data)) throw new Error("manifest_invalid");
        return data.map(d => normalizeExam({ ...d, type: "builtin" }));
      } catch {
        return null;
      }
    }

    function mergeBuiltinAndSaved(builtinList, savedList) {
      const combined = [
        ...(builtinList || []),
        ...(savedList || [])
      ].map(normalizeExam);

      combined.sort((a,b) => (a.addedAt || 0) - (b.addedAt || 0));
      return combined;
    }

    async function init() {
      setStatus("Loading exam list...", "");

      const builtin = await fetchManifest();
      const saved = loadSavedList().map(normalizeExam);

      let combined = [];
      if (builtin === null) {
        combined = mergeBuiltinAndSaved([], saved);
        exams = applyDeletedFilter(combined);

        selectedIds = loadSavedSelection();
        const existingIds = new Set(exams.map(e => e.id));
        selectedIds = new Set(Array.from(selectedIds).filter(id => existingIds.has(id)));
        saveSelection();

        setStatus("manifest.json not found (or invalid). Showing uploaded exams only.", "err");
        renderList();
        return;
      }

      combined = mergeBuiltinAndSaved(builtin, saved);
      exams = applyDeletedFilter(combined);

      saveList(saved);

      selectedIds = loadSavedSelection();
      const existingIds = new Set(exams.map(e => e.id));
      selectedIds = new Set(Array.from(selectedIds).filter(id => existingIds.has(id)));
      saveSelection();

      setStatus("Ready.", "ok");
      renderList();
      if (selectedIds.size > 0) estimateTotalQuestions();
    }

    // Buttons
    document.getElementById("btn-refresh").addEventListener("click", () => init());

    document.getElementById("btn-select-all").addEventListener("click", () => {
      selectedIds = new Set(exams.map(e => e.id));
      saveSelection();
      renderList();
      estimateTotalQuestions();
      setStatus("Selected all exams.", "ok");
    });

    document.getElementById("btn-clear-select").addEventListener("click", () => {
      selectedIds.clear();
      saveSelection();
      renderList();
      updateSelectedUI();
      setStatus("", "");
    });

    document.getElementById("btn-delete-selected").addEventListener("click", () => {
      if (selectedIds.size === 0) return;

      const ids = Array.from(selectedIds);
      for (const id of ids) deleteExamById(id);

      selectedIds.clear();
      saveSelection();
      setStatus("Deleted selected exams from list.", "ok");
      init();
    });

    // Checkbox change (keep)
    $items.addEventListener("change", (e) => {
      const chk = e.target.closest(".chk");
      if (!chk) return;
      const id = chk.getAttribute("data-id");
      if (!id) return;

      if (chk.checked) selectedIds.add(id);
      else selectedIds.delete(id);

      saveSelection();
      updateSelectedUI();
      estimateTotalQuestions();
    });

    // Click handlers: delete OR row-toggle
    $items.addEventListener("click", (e) => {
      // delete X
      const x = e.target.closest(".xbtn");
      if (x) {
        const id = x.getAttribute("data-id");
        if (id) {
          deleteExamById(id);
          setStatus("Deleted.", "ok");
        }
        return;
      }

      // ignore if clicking checkbox
      if (e.target.closest("input[type='checkbox']")) return;

      // row toggle
      const row = e.target.closest(".item");
      if (!row) return;

      const examId = row.getAttribute("data-id");
      if (!examId) return;

      const checkbox = row.querySelector("input[type='checkbox']");
      if (!checkbox) return;

      checkbox.checked = !checkbox.checked;
      checkbox.dispatchEvent(new Event("change", { bubbles: true }));
    });

    // Double click row -> preview
    $items.addEventListener("dblclick", (e) => {
      // ignore dblclick on checkbox or X
      if (e.target.closest("input[type='checkbox']") || e.target.closest(".xbtn")) return;

      const row = e.target.closest(".item");
      if (!row) return;

      const examId = row.getAttribute("data-id");
      if (!examId) return;

      previewExam(examId);
    });

    // Upload with duplicate confirm overwrite
    $upload.addEventListener("change", async function (e) {
      const files = Array.from(e.target.files || []);
      if (files.length === 0) return;

      setStatus(`Uploading ${files.length} file(s)...`, "");

      const saved = loadSavedList().map(normalizeExam);

      let addedCount = 0;
      let overwroteCount = 0;

      for (const file of files) {
        const text = await file.text();
        const parsed = safeJsonParse(text);

        if (!parsed) {
          setStatus(`Invalid JSON: ${file.name}`, "err");
          continue;
        }

        const newId = "upload_" + Date.now() + "_" + Math.random().toString(16).slice(2);
        const title = file.name.replace(/\.json$/i, "");
        const candidate = normalizeExam({ id: newId, title, type:"uploaded", addedAt:Date.now(), fileName:file.name });

        const dup = findDuplicate(exams, candidate);

        if (dup) {
          const dupName = dup.fileName || baseNameFromPath(dup.src) || dup.title || "unknown";
          const ok = confirm(`ƒê√£ load r·ªìi: ${dupName}\nB·∫°n c√≥ mu·ªën ghi ƒë√® kh√¥ng?`);
          if (!ok) continue;

          if (dup.type === "uploaded") {
            localStorage.removeItem(LS_UPLOAD_PREFIX + dup.id);
            for (let i = saved.length - 1; i >= 0; i--) {
              if (saved[i].id === dup.id) saved.splice(i, 1);
            }
          } else {
            const deleted = loadDeletedSet();
            deleted.add(dup.id);
            saveDeletedSet(deleted);
            selectedIds.delete(dup.id);
          }

          try {
            localStorage.setItem(LS_UPLOAD_PREFIX + newId, JSON.stringify(parsed));
          } catch {
            setStatus("V∆∞·ª£t b·ªô nh·ªõ localStorage. Kh√¥ng th·ªÉ l∆∞u th√™m ƒë·ªÅ.", "err");
            break;
          }

          saved.push(candidate);
          selectedIds.add(newId); // auto-select
          overwroteCount++;
          continue;
        }

        try {
          localStorage.setItem(LS_UPLOAD_PREFIX + newId, JSON.stringify(parsed));
        } catch {
          setStatus("V∆∞·ª£t b·ªô nh·ªõ localStorage. Kh√¥ng th·ªÉ l∆∞u th√™m ƒë·ªÅ.", "err");
          break;
        }

        saved.push(candidate);
        selectedIds.add(newId); // auto-select
        addedCount++;
      }

      saveList(saved);
      saveSelection();
      e.target.value = "";

      await init();
      renderList();

      if (overwroteCount > 0 || addedCount > 0) {
        setStatus(`Added: ${addedCount}, Overwrote: ${overwroteCount}. Auto-selected new items.`, "ok");
      } else {
        setStatus("No exams added.", "err");
      }

      estimateTotalQuestions();
    });

    // Load Tests: block if too big
    document.getElementById("btn-load-tests").addEventListener("click", async () => {
      if (selectedIds.size === 0) return;

      const selected = exams.filter(e => selectedIds.has(e.id));
      setStatus(`Loading ${selected.length} selected exam(s)...`, "");

      try {
        const questionsByExam = new Map();
        let sampleBytes = 0;

        for (const ex of selected) {
          const qs = await readExamQuestions(ex);
          questionsByExam.set(ex.id, qs);

          const slice = (qs || []).slice(0, 10);
          sampleBytes += estimateBytesForString(JSON.stringify(slice));
        }

        const combined = buildCombinedQuestions(selected, questionsByExam);
        const combinedStr = JSON.stringify(combined);
        const bytes = estimateBytesForString(combinedStr);

        const sampleQCount = selected.reduce((acc, ex) => {
          const qs = questionsByExam.get(ex.id) || [];
          return acc + Math.min(10, qs.length);
        }, 0);

        let avgBytesPerQ = 3000;
        if (sampleQCount > 0 && sampleBytes > 0) {
          avgBytesPerQ = Math.max(1, Math.floor(sampleBytes / sampleQCount));
        }

        const maxQuestions = Math.floor(LOCALSTORAGE_SAFE_BYTES / avgBytesPerQ);

        if (bytes > LOCALSTORAGE_SAFE_BYTES) {
          setStatus(
            `V∆∞·ª£t b·ªô nh·ªõ localStorage v√¨ ƒë·ªÅ d·ªìn qu√° nhi·ªÅu.\n` +
            `Kh√¥ng v∆∞·ª£t ~${maxQuestions} c√¢u.\n` +
            `H√£y ch·ªçn √≠t ƒë·ªÅ h∆°n.`,
            "err"
          );
          return;
        }

        try {
          localStorage.setItem("pmp_questions", combinedStr);
          localStorage.setItem("pmp_selected_exams_meta", JSON.stringify(
            selected.map(x => ({ id: x.id, title: x.title, type: x.type, src: x.src || null }))
          ));
        } catch {
          setStatus(
            `V∆∞·ª£t b·ªô nh·ªõ localStorage v√¨ ƒë·ªÅ d·ªìn qu√° nhi·ªÅu.\n` +
            `Kh√¥ng v∆∞·ª£t ~${maxQuestions} c√¢u.\n` +
            `H√£y ch·ªçn √≠t ƒë·ªÅ h∆°n.`,
            "err"
          );
          return;
        }

        setStatus(`Success. Total questions loaded: ${combined.length}. Redirecting...`, "ok");
        setTimeout(() => {
          window.location.href = "questionsList.html";
        }, 450);

      } catch {
        setStatus("Failed to load selected exams. Check manifest/src paths or JSON format.", "err");
      }
    });

    // Boot
    init();
  </script>
</body>
</html>